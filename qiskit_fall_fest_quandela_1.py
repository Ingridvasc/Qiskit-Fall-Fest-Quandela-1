# -*- coding: utf-8 -*-
"""Qiskit Fall Fest Quandela 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11ATOvNmmz6TAmDjTx2m0yiwZ-YKRSRu1
"""

# Installation
!pip install qiskit qiskit-aer matplotlib scipy numpy

import numpy as np
from scipy.stats import norm
import math
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

# Import Qiskit components - MODERN SYNTAX
from qiskit import QuantumCircuit, QuantumRegister
from qiskit_aer import Aer, AerSimulator
from qiskit.quantum_info import Statevector

print("All imports successful!")

class QuantumOptionPricing:
    """
    Quantum Random Walk implementation for option pricing
    using the Black-Scholes model
    """

    def __init__(self, n_qubits=4, n_timesteps=3):
        self.n_qubits = n_qubits
        self.n_timesteps = n_timesteps
        self.backend = Aer.get_backend('statevector_simulator')

    def create_quantum_walk_circuit(self, theta, phi):
        """
        Creates quantum random walk circuit to model price evolution
        """
        qr = QuantumRegister(self.n_qubits, 'q')
        qc = QuantumCircuit(qr)

        # Initial state - represents initial price
        # Initialize with superposition to explore multiple paths
        for qubit in range(self.n_qubits):
            qc.h(qubit)

        # Quantum random walk steps
        for step in range(self.n_timesteps):
            # Apply rotations to simulate Brownian motion
            for qubit in range(self.n_qubits):
                qc.ry(theta * (step + 1) / self.n_timesteps, qubit)
                qc.rz(phi * (step + 1) / self.n_timesteps, qubit)

            # Apply entanglement to correlate price movements
            for i in range(self.n_qubits - 1):
                qc.cx(i, i + 1)

            # Diffusion step for random walk behavior
            if step < self.n_timesteps - 1:
                for qubit in range(self.n_qubits):
                    qc.h(qubit)

        return qc

    def map_finance_to_quantum(self, S0, K, r, sigma, T):
        """
        Maps financial parameters to quantum parameters
        """
        # Calculate quantum parameters based on financial model
        drift_quantum = (r - 0.5 * sigma ** 2) * T * np.pi
        volatility_quantum = sigma * np.sqrt(T) * 2 * np.pi

        return drift_quantum, volatility_quantum

    def get_quantum_probabilities(self, qc):
        """
        Gets probability distribution from quantum circuit
        """
        # Modern way to execute circuits
        simulator = AerSimulator()

        # Convert to statevector
        statevector = Statevector(qc)
        probabilities = np.abs(statevector)**2

        return probabilities

    def calculate_quantum_payoff(self, probabilities, S0, K, option_type='call'):
        """
        Calculates expected payoff based on quantum probability distribution
        """
        n_states = 2**self.n_qubits
        payoffs = np.zeros(n_states)

        # Map quantum states to asset prices
        for i in range(n_states):
            # Convert binary state to price movement
            state_value = i / (n_states - 1) if n_states > 1 else 0.5
            price_ratio = -3 + 6 * state_value  # Map to [-3, 3] standard deviations

            ST = S0 * np.exp(price_ratio)  # Final simulated price

            if option_type == 'call':
                payoff = max(ST - K, 0)
            else:  # put
                payoff = max(K - ST, 0)

            payoffs[i] = payoff

        expected_payoff = np.sum(probabilities * payoffs)
        return expected_payoff, payoffs

    def price_option_quantum(self, S0, K, r, sigma, T, option_type='call'):
        """
        Prices option using quantum random walk
        """
        # Get quantum parameters from financial parameters
        theta, phi = self.map_finance_to_quantum(S0, K, r, sigma, T)

        # Create quantum circuit
        qc = self.create_quantum_walk_circuit(theta, phi)

        # Get probability distribution
        probabilities = self.get_quantum_probabilities(qc)

        # Calculate expected payoff
        expected_payoff, payoffs = self.calculate_quantum_payoff(probabilities, S0, K, option_type)

        # Discount to present value
        option_price = np.exp(-r * T) * expected_payoff

        return {
            'quantum_price': option_price,
            'probabilities': probabilities,
            'payoffs': payoffs,
            'circuit': qc,
            'expected_payoff': expected_payoff,
            'parameters': {'theta': theta, 'phi': phi}
        }

    def analyze_circuit_complexity(self, qc):
        """
        Analyzes quantum circuit complexity
        """
        depth = qc.depth()
        gate_counts = qc.count_ops()
        total_gates = sum(gate_counts.values())

        return {
            'depth': depth,
            'gate_counts': gate_counts,
            'total_gates': total_gates,
            'n_qubits': self.n_qubits
        }

# Classical methods for comparison
def black_scholes_call_analytic(S0, K, r, sigma, T):
    """Analytical Black-Scholes call price"""
    if T <= 0:
        return max(S0 - K, 0)

    d1 = (np.log(S0 / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)

def black_scholes_put_analytic(S0, K, r, sigma, T):
    """Analytical Black-Scholes put price"""
    if T <= 0:
        return max(K - S0, 0)

    d1 = (np.log(S0 / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))
    d2 = d1 - sigma * np.sqrt(T)
    return K * np.exp(-r * T) * norm.cdf(-d2) - S0 * norm.cdf(-d1)

def monte_carlo_option_price(S0, K, r, sigma, T, n_sim=10000, option_type='call'):
    """Monte Carlo option pricing"""
    z = np.random.normal(0, 1, n_sim)
    ST = S0 * np.exp((r - 0.5 * sigma ** 2) * T + sigma * np.sqrt(T) * z)

    if option_type == 'call':
        payoff = np.maximum(ST - K, 0)
    else:
        payoff = np.maximum(K - ST, 0)

    price = np.exp(-r * T) * np.mean(payoff)
    std_error = np.exp(-r * T) * np.std(payoff) / np.sqrt(n_sim)

    return price, std_error

def create_comparison_plots(quantum_call, quantum_put, classical_call, classical_put, mc_call, mc_put):
    """Create comparison plots for results"""

    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 12))

    # Probability distribution
    ax1.bar(range(len(quantum_call['probabilities'])), quantum_call['probabilities'], alpha=0.7)
    ax1.set_title('Quantum Probability Distribution')
    ax1.set_xlabel('Quantum State')
    ax1.set_ylabel('Probability')
    ax1.grid(True, alpha=0.3)

    # Payoff distribution
    ax2.bar(range(len(quantum_call['payoffs'])), quantum_call['payoffs'], alpha=0.7, color='orange')
    ax2.set_title('Option Payoffs by Quantum State')
    ax2.set_xlabel('Quantum State')
    ax2.set_ylabel('Payoff')
    ax2.grid(True, alpha=0.3)

    # Call option comparison
    methods = ['Quantum RW', 'Analytic BS', 'Monte Carlo']
    call_prices = [quantum_call['quantum_price'], classical_call, mc_call]
    colors = ['blue', 'green', 'red']

    bars = ax3.bar(methods, call_prices, color=colors, alpha=0.7)
    ax3.set_title('Call Option Price Comparison')
    ax3.set_ylabel('Price')
    ax3.grid(True, alpha=0.3)

    # Add value labels on bars
    for bar, price in zip(bars, call_prices):
        ax3.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                f'${price:.2f}', ha='center', va='bottom')

    # Put option comparison
    put_prices = [quantum_put['quantum_price'], classical_put, mc_put]

    bars = ax4.bar(methods, put_prices, color=colors, alpha=0.7)
    ax4.set_title('Put Option Price Comparison')
    ax4.set_ylabel('Price')
    ax4.grid(True, alpha=0.3)

    # Add value labels on bars
    for bar, price in zip(bars, put_prices):
        ax4.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                f'${price:.2f}', ha='center', va='bottom')

    plt.tight_layout()
    plt.savefig('quantum_finance_results.png', dpi=300, bbox_inches='tight')
    plt.show()

    # Save quantum circuit diagram
    try:
        quantum_call['circuit'].draw(output='mpl', filename='quantum_circuit_diagram.png')
        print("Quantum circuit diagram saved as 'quantum_circuit_diagram.png'")
    except Exception as e:
        print(f"Could not save circuit diagram: {e}")

def run_comprehensive_analysis():
    """Run comprehensive analysis of quantum vs classical methods"""

    # Test parameters
    S0 = 100
    K = 100
    r = 0.05
    sigma = 0.2
    T = 1

    print("=== QUANTUM OPTION PRICING ANALYSIS ===")
    print(f"Parameters: S0={S0}, K={K}, r={r}, Ïƒ={sigma}, T={T}")
    print()

    # Initialize quantum pricer
    quantum_pricer = QuantumOptionPricing(n_qubits=4, n_timesteps=3)

    # Classical prices
    classical_call = black_scholes_call_analytic(S0, K, r, sigma, T)
    classical_put = black_scholes_put_analytic(S0, K, r, sigma, T)

    mc_call, mc_call_error = monte_carlo_option_price(S0, K, r, sigma, T, 10000, 'call')
    mc_put, mc_put_error = monte_carlo_option_price(S0, K, r, sigma, T, 10000, 'put')

    # Quantum prices
    print("Calculating quantum prices...")
    quantum_call = quantum_pricer.price_option_quantum(S0, K, r, sigma, T, 'call')
    quantum_put = quantum_pricer.price_option_quantum(S0, K, r, sigma, T, 'put')

    # Circuit analysis
    circuit_analysis = quantum_pricer.analyze_circuit_complexity(quantum_call['circuit'])

    # Print results
    print("CALL OPTION PRICING RESULTS:")
    print(f"{'Method':<20} {'Price':<10} {'Error vs Analytic':<18}")
    print("-" * 50)
    print(f"{'Analytic':<20} ${classical_call:<9.4f} {'-':<18}")
    print(f"{'Monte Carlo':<20} ${mc_call:<9.4f} ${abs(mc_call - classical_call):<17.4f}")
    print(f"{'Quantum RW':<20} ${quantum_call['quantum_price']:<9.4f} ${abs(quantum_call['quantum_price'] - classical_call):<17.4f}")
    print()

    print("PUT OPTION PRICING RESULTS:")
    print(f"{'Method':<20} {'Price':<10} {'Error vs Analytic':<18}")
    print("-" * 50)
    print(f"{'Analytic':<20} ${classical_put:<9.4f} {'-':<18}")
    print(f"{'Monte Carlo':<20} ${mc_put:<9.4f} ${abs(mc_put - classical_put):<17.4f}")
    print(f"{'Quantum RW':<20} ${quantum_put['quantum_price']:<9.4f} ${abs(quantum_put['quantum_price'] - classical_put):<17.4f}")
    print()

    print("=== QUANTUM CIRCUIT ANALYSIS ===")
    print(f"Number of qubits: {circuit_analysis['n_qubits']}")
    print(f"Circuit depth: {circuit_analysis['depth']}")
    print(f"Total gates: {circuit_analysis['total_gates']}")
    print(f"Gate counts: {circuit_analysis['gate_counts']}")

    # Visualization
    create_comparison_plots(quantum_call, quantum_put, classical_call, classical_put, mc_call, mc_put)

    return {
        'quantum_call': quantum_call,
        'quantum_put': quantum_put,
        'classical_call': classical_call,
        'classical_put': classical_put,
        'mc_call': mc_call,
        'mc_put': mc_put,
        'circuit_analysis': circuit_analysis
    }

# Run the complete analysis
print("Starting Quantum Option Pricing Analysis...")
print()

try:
    results = run_comprehensive_analysis()
    print("Main analysis completed successfully!")

    # Additional analysis: Scaling with number of qubits
    print("\n" + "="*50)
    print("SCALING ANALYSIS")
    print("="*50)

    for n_qubits in [3, 4, 5]:
        print(f"\nTesting with {n_qubits} qubits...")
        qp = QuantumOptionPricing(n_qubits=n_qubits, n_timesteps=2)
        quantum_result = qp.price_option_quantum(100, 100, 0.05, 0.2, 1, 'call')
        circuit_info = qp.analyze_circuit_complexity(quantum_result['circuit'])
        error = abs(quantum_result['quantum_price'] - results['classical_call'])
        print(f"Qubits: {n_qubits}, Price: ${quantum_result['quantum_price']:.4f}, Error: ${error:.4f}, Gates: {circuit_info['total_gates']}")

    print("\All analyses completed successfully!")
    print("Generated files:")
    print("quantum_finance_results.png - Comparison charts")
    print("quantum_circuit_diagram.png - Quantum circuit visualization")

except Exception as e:
    print(f"Error during analysis: {e}")
    import traceback
    traceback.print_exc()

    # Fallback: Show classical results only
    print("\n" + "="*50)
    print("FALLBACK: CLASSICAL METHODS RESULTS")
    print("="*50)

    S0, K, r, sigma, T = 100, 100, 0.05, 0.2, 1
    call_bs = black_scholes_call_analytic(S0, K, r, sigma, T)
    put_bs = black_scholes_put_analytic(S0, K, r, sigma, T)
    call_mc, _ = monte_carlo_option_price(S0, K, r, sigma, T, 'call')
    put_mc, _ = monte_carlo_option_price(S0, K, r, sigma, T, 'put')

    print("\nClassical Methods Results:")
    print(f"Call - Black-Scholes: ${call_bs:.4f}")
    print(f"Call - Monte Carlo:   ${call_mc:.4f}")
    print(f"Put - Black-Scholes:  ${put_bs:.4f}")
    print(f"Put - Monte Carlo:    ${put_mc:.4f}")